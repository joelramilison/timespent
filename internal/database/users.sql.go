// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, username, created_at, updated_at, password_hash, time_zone, session_id_hash, session_expires_at)
VALUES (
    $1, $2, NOW(), NOW(), $3, $4, $5, $6
)
RETURNING id, created_at, updated_at, username, password_hash, time_zone, session_id_hash, session_expires_at, await_assign_decision_until
`

type CreateUserParams struct {
	ID               uuid.UUID
	Username         string
	PasswordHash     []byte
	TimeZone         string
	SessionIDHash    []byte
	SessionExpiresAt sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.PasswordHash,
		arg.TimeZone,
		arg.SessionIDHash,
		arg.SessionExpiresAt,
	)
	return err
}

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at, username, password_hash, time_zone, session_id_hash, session_expires_at, await_assign_decision_until FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.PasswordHash,
		&i.TimeZone,
		&i.SessionIDHash,
		&i.SessionExpiresAt,
		&i.AwaitAssignDecisionUntil,
	)
	return i, err
}

const getUserbyName = `-- name: GetUserbyName :one
SELECT id, created_at, updated_at, username, password_hash, time_zone, session_id_hash, session_expires_at, await_assign_decision_until FROM users
WHERE username = $1
`

func (q *Queries) GetUserbyName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserbyName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.PasswordHash,
		&i.TimeZone,
		&i.SessionIDHash,
		&i.SessionExpiresAt,
		&i.AwaitAssignDecisionUntil,
	)
	return i, err
}

const logUserOut = `-- name: LogUserOut :exec
UPDATE users
SET updated_at = NOW(), session_expires_at = NULL, session_id_hash = NULL
WHERE id = $1
`

func (q *Queries) LogUserOut(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, logUserOut, id)
	return err
}

const updateAssignAwait = `-- name: UpdateAssignAwait :exec
UPDATE users
SET updated_at = NOW(), await_assign_decision_until = $1
WHERE id = $2
`

type UpdateAssignAwaitParams struct {
	AwaitAssignDecisionUntil sql.NullTime
	ID                       uuid.UUID
}

func (q *Queries) UpdateAssignAwait(ctx context.Context, arg UpdateAssignAwaitParams) error {
	_, err := q.db.ExecContext(ctx, updateAssignAwait, arg.AwaitAssignDecisionUntil, arg.ID)
	return err
}

const updateLoginSession = `-- name: UpdateLoginSession :exec
UPDATE users
SET updated_at = NOW(), session_expires_at = $1, session_id_hash = $2
WHERE id = $3
`

type UpdateLoginSessionParams struct {
	SessionExpiresAt sql.NullTime
	SessionIDHash    []byte
	ID               uuid.UUID
}

func (q *Queries) UpdateLoginSession(ctx context.Context, arg UpdateLoginSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateLoginSession, arg.SessionExpiresAt, arg.SessionIDHash, arg.ID)
	return err
}
